			Функции:
		Pipex:

int access(const char *pathname, int mode); - проверяет имеет ли процесс права на чтение и запись
! 0 / -1
[1] имя файла
[2] маска из флагов (default 0 (F_OK), F_OK просто проверяет существование файла.) 


int open(const char *pathname, int flags, mode_t mode); - открывает 
! fd и -1 если ошибка
[1] путь к файлу
[2] флаги [O_RDONLY - только чтение, (O_CREAT | O_WRONLY | O_TRUNC) - создать, только записью, очистить] 
-[3] права доступа [0644 - -rw-r--r--]

int unlink(const char *pathname); - удаляет файл с помощью системной функции unlink  
! 0 / -1
[1] путь к файлу 

pid_t wait(int *status); - приостанавливает выполнение текущего процесса, пока дочерний процесс не завершится, или до появления сигнала
! pid дочернего процесса и -1 если ошибка

pid_t waitpid(pid_t pid, int *status, int options);  - приостанавливает выполнение текущего процесса, пока дочерний процесс pid, не завершится
! pid дочернего процесса и -1 если ошибка
[0] pid дочернего процесса 
[1] [2] - можно по 0 ставить


int pipe(int filedes[2]);  - создает канал
! 0 / -1
pipe создает пару fd, указывающих на запись inode именованного канала, помещает в массив *filedes. filedes[0] чтение, filedes[1] запись.

int dup(int oldfd); - создать дубликат файлового дескриптора
int dup2(int oldfd, int newfd);
! новый fd / -1
dup использует самый маленький свободный номер дескриптора.
dup2 делает newfd копией oldfd, закрывая newfd, если требуется.  

int execve(const char *filename, char *const argv [], char *const envp[]); - выполняет программу
! -1 если ошибка
[1] Программа должна быть или двоичным исполняемым файлом, или скриптом, начинающимся со строки "#! интерпретатор [аргументы]". Интерпретатор - это путь к исполняемому файлу, который не является скриптом; этот файл будет выполнен как интерпретатор [arg] filename.
[2] argv - это массив строк, аргументов новой программы. 
[3] envp - это массив строк в формате key=value, которые передаются новой программе в качестве окружения

pid_t fork(void);  - создает дочерний процесс  
! pid потомка / -1
fork создает процесс-потомок, который отличается от родительского только значениями PID и PPID (идентификатор родительского процесса)


		minishell:
Из pipex: malloc, free, write, access, fork, wait, waitpid, unlink, execve, dup, dup2, pipe

readline - свободная библиотека для интерфейса командной строки и обработки строк

char *readline(const char *prompt); - взять строку от пользователя с редактированием

void rl_clear_history(void); - Удаляет список историий посредством удалением всех вхождений, также как и clear_history. Также очищает личные данные Readline в списке историй
Clear the history list by deleting all of the entries, in the same manner as the History library's clear_history() function. 

int rl_on_new_line(void); - перемещаемся на новую линию, обычно после вывода новой линии
Tell the update routines that we have moved onto a new (empty) line, usually after ouputting a newline.

void rl_replace_line (const char *text, int clear_undo) - Replace the contents of rl_line_buffer with text. The point and mark are preserved, if possible. If clear_undo is non-zero, the undo list associated with the current line is cleared.

void rl_redisplay (void) - Change what's displayed on the screen to reflect the current contents of rl_line_buffer.

void add_history (const char *string) - Place string at the end of the history list. The associated data field (if any) is set to NULL. If the maximum number of history entries has been set using stifle_history(), and the new number of history entries would exceed that maximum, the oldest history entry is removed.

pid_t wait3(int *status, int options, struct rusage *rusage); - приостанавливает исполнение текущего процесса до того, как дочерний процесс завершит свою работу, или он не получит сигнал, прекращающий его работу, или не будет произведен вызов обработчика прерывания. 
! ID дочернего процесса, прекратившего работу / -1
pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage); - приостанавливает исполнение текущего процесса до того, как свою работу завершит дочерний процесс с номером pid, или этот процесс не получит сигнал, прекращающий его работу, или не будет произведен вызов обработчика прерывания.
! ID дочернего процесса, прекратившего работу / -1
[1] - ID дочернего процесса
[2] - информация о процессе в структуре status
[3] - флаги возвращения управления (0)
[4] - структура использования информации (0)
Если дочерний процесс уже прекратил свою работу на момент вызова этих функций (такой процесс называется "зомби" ("zombie")), то функции немедленно возвращается.

char *getcwd(char *buf, size_t size);
копирует абсолютный путь к текущему рабочему каталогу в массиве, на который указывает buf, имеющий длину size.
! / NULL при ошибках

int chdir(const char *path); - изменяет текущий каталог каталог на path.
! 0 / -1

int stat(const char *file_name, struct stat *buf); - считывает статус файла
! 0 / -1
[1] информация о файле file_name
[2] структура status
int fstat(int filedes, struct stat *buf); - идентична stat, только возвращается информация об открытом файле, на который указывает filedes
int lstat(const char *file_name, struct stat *buf);  идентична stat, но в случае символьных сылок она возвращает информацию о самой ссылке, а не о файле, на который она указывает. 

DIR *opendir(const char *name); - открывает поток каталога, соответствующий каталогу name, и возвращает указатель на этот поток
! указатель на поток каталога / NULL в случае ошибок. 

struct dirent *readdir(DIR *dir); - возвращает указатель на следующую запись каталога в структуре dirent, прочитанную из потока каталога. Каталог указан в dir. 
! указатель на структуру dirent / NULL в случае ошибки или по достижении последней записи. 

int closedir(DIR *dir); - функция closedir() закрывает поток, связанный с каталогом dir.
! 0 / -1

int isatty(int desc); - определяет, ссылается ли данный описатель на терминал ! 1 если открытый / 0 если

char *ttyname(int fd); -  возвращает указатель на полное имя устройства терминала, открытого на fd / NULL 

int ttyslot(void); - возвращает индекс текущей записи пользователя в некотором файле.

int ioctl(int d, int request, ...);  - манипулирует базовыми параметрами устройств, представленных в виде специальных файлов. В частности, многими оперативными характеристиками специальных символьных файлов можно управлять через ioctl запросы. 
В качестве аргумента d должен быть указан открытый файловый дескриптор.

char *getenv(const char *name); - ищет в списке окружения строку, совпадающую со строкой, указанной в name. Строки имеют вид имя = значение.  

pid_t tcgetpgrp(int fd); - возвращает идентификатор группы процессов для основной группы процессов терминала, ассоциированного с fd, который должен быть управляющим терминалом для вызывающего процесса.

int tcsetpgrp(int fd, pid_t pgrp);  - делает группу процессов с идентификатором pgrp основной группой процессов на терминале, ассоциированном с fd, который должен быть управляющим терминалом для вызывающего процесса, и все еще быть ассоциированным с его сессией.
Более того, pgrp должно быть (непустой) группой процессов, принадлежащих к той же сессии, что и вызывающий процесс.

int tgetent(char *bp, const char *name); - routine loads the entry for name. It returns 1 on success, 0 if there is no such entry, and -1 if the terminfo database could not be found. The emulation ignores the buffer pointer bp.
int tgetflag(char *id); - routine gets the boolean entry for id, or zero if it is not available.
int tgetnum(char *id); -  routine gets the numeric entry for id, or -1 if it is not available.
char *tgetstr(char *id, char **area); - routine returns the string entry for id, or zero if it is not available. Use tputs to output the returned string. The return value will also be copied to the buffer pointed to by area, and the area value will be updated to point past the null ending this value.
char *tgoto(const char *cap, int col, int row); - routine instantiates the parameters into the given capability. The output from this routine is to be passed to tputs.
int tputs(const char *str, int affcnt, int (*putc)(int));

		Комманды необходимые реализовать в minishell:

